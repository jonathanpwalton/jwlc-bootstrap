#!/usr/bin/env python3

from pprint import pprint
from string import ascii_letters as ASCII_ALPHA, digits as ASCII_DIGIT
from typing import Any, Literal, TypedDict, Callable, List
from pathlib import Path
from tempfile import NamedTemporaryFile
from subprocess import run
from dataclasses import dataclass

class Dictionary(TypedDict):
	__getattr__ = dict.get
	__setattr__ = dict.__setitem__
	__delattr__ = dict.__delitem__

@dataclass
class Error(BaseException):
	msg: str

@dataclass
class Where:
	src: Path
	row: int
	col: int

	def __iter__(self):
		return iter((self.src, self.row, self.col))

	def error(self, msg: str):
		raise Error(f'\033[0m\033[1;97m{self.src}:{self.row}:{self.col}: \033[1;91merror: \033[0m{msg}')

@dataclass
class Tokens:
	path: Path
	tokens: 'list[Tokens.Token]' = None
	index: int = 0

	@dataclass
	class Token:
		where: Where
		value: str | float | int | bytes

		def error(self, msg: str):
			self.where.error(msg)
	class Newline(Token): pass
	class Indent(Token): pass
	class Symbol(Token): pass
	class Keyword(Token): pass
	class Name(Token): pass
	class Integer(Token): pass
	class Scalar(Token): pass
	class String(Token): complete: bool = False

	def __post_init__(self):
		KEYWORDS = ['function', 'return']
		self.tokens: 'list[Tokens.Token]' = [Tokens.Newline(Where(self.path, 0, 0), '\n')]

		row = 1
		col = 1
		for char in open(self.path).read():
			if type(self.tokens[-1]) is Tokens.String and not self.tokens[-1].complete:
				if char in ['"', "'"] and not self.tokens[-1].value.endswith('\\'):
					self.tokens[-1].complete = True
				else:
					self.tokens[-1].value += char
			elif char == '\n':
				if type(self.tokens[-1]) is not Tokens.Newline:
					if type(self.tokens[-1]) is Tokens.Indent:
						self.tokens.pop()
					else:
						self.tokens.append(Tokens.Newline(Where(self.path, row, col), char))
			elif char.isspace():
				if type(self.tokens[-1]) is Tokens.Newline:
					self.tokens.append(Tokens.Indent(Where(self.path, row, col), ' '))
				elif type(self.tokens[-1]) is Tokens.Indent:
					self.tokens[-1].value += ' '
				else:
					self.tokens.append(Tokens.Token(Where(self.path, row, col), ' '))
			elif char in ASCII_ALPHA:
				if type(self.tokens[-1]) is Tokens.Name:
					self.tokens[-1].value += char
				else:
					self.tokens.append(Tokens.Name(Where(self.path, row, col), char))
			elif char in ASCII_DIGIT:
				if type(self.tokens[-1]) in [Tokens.Name, Tokens.Integer, Tokens.Scalar]:
					self.tokens[-1].value += char
				else:
					self.tokens.append(Tokens.Integer(Where(self.path, row, col), char))
			elif char in ["'", '"']:
				self.tokens.append(Tokens.String(Where(self.path, row, col), ''))
			elif char == '_' and type(self.tokens[-1]) is Tokens.Name:
				self.tokens[-1].value += char
			elif char == '.' and type(self.tokens[-1]) is Tokens.Integer:
				self.tokens[-1] = Tokens.Scalar(self.tokens[-1].where, self.tokens[-1].value + '.')
			else:
				self.tokens.append(Tokens.Symbol(Where(self.path, row, col), char))

			if char == '\n':
				row += 1
				col = 0
			col += 1

		if type(self.tokens[-1]) is Tokens.String and not self.tokens[-1].complete:
			self.tokens[-1].error('unclosed string literal')
		elif type(self.tokens[-1]) is Tokens.Indent:
			self.tokens.pop()

		self.tokens = self.tokens[1:]
		if len(self.tokens) == 0 or type(self.tokens[-1]) is not Tokens.Newline:
			self.tokens.append(Tokens.Newline(Where(self.path, row, col), '\n'))

		def revalue(token: 'Tokens.Token') -> 'Tokens.Token':
			if type(token) is Tokens.Integer:
				token.value = int(token.value)
			elif type(token) is Tokens.Scalar:
				token.value = float(token.value)
			elif type(token) is Tokens.String:
				token.value = token.value.encode('utf-8').decode('unicode_escape').encode('utf-8')
				del token.complete
			elif type(token) is Tokens.Name and token.value in KEYWORDS:
				token = Tokens.Keyword(token.where, token.value)
			return token

		self.tokens = [revalue(token) for token in self.tokens if type(token) is not Tokens.Token]

	def error(self, msg: str):
		Where(self.path, self.tokens[-1].where.row, self.tokens[-1].where.col + len(self.tokens[-1].value)) if self.index >= len(self.tokens) else self.front().error(msg)

	def empty(self) -> bool:
		return self.index >= len(self.tokens)
	
	def __len__(self) -> int:
		return len(self.tokens)

	def front(self) -> 'Tokens.Token | None':
		return self.tokens[self.index] if self.index < len(self.tokens) else None
	
	def value(self) -> str:
		return self.front().value if self.front() else None
	
	def where(self) -> Where:
		return self.front().where if self.front() else None

	def expect(self, *values: str | type) -> 'Tokens.Token | list[Tokens.Token]':
		assert len(values) and all([type(x) for x in values])
		
		def rep(value: str | type):
			return value.__name__ if type(value) is type else repr(value)

		ret: 'list[Tokens.Token]' = []
		for value in values:
			if self.index >= len(self.tokens):
				self.error(f'expected {rep(value)} but reached end of input')
			elif type(value) is str and self.tokens[self.index].value != value:
				self.error(f'expected {rep(value)} but found {rep(self.tokens[self.index].value)}')
			elif type(value) is type and type(self.tokens[self.index]) != value:
				self.error(f'expected {rep(value)} but found {rep(type(self.tokens[self.index]))}')
			ret.append(self.tokens[self.index])
			self.index += 1
		return ret[0] if len(ret) == 1 else ret
	
	def follow(self, value: Any, *expected: str | type) -> Any:
		self.expect(*expected)
		return value
	
	def remaining(self) -> int:
		return abs(len(self.tokens) - self.index)
	
	def type(self) -> type:
		return type(self.front())

class Types:
	@dataclass
	class Type:
		name: str
		size: int

		def __str__(self):
			return self.name

	@dataclass
	class Integer(Type):
		name: Literal['u8', 'u16', 'u32', 'u64', 'i8', 'i16', 'i32', 'i64']
		size: Literal[1, 2, 4, 8]

	@dataclass
	class Pointer(Type):
		name: Literal['ptr']
		size: Literal[8]
		value: 'Types.Type | None'

		def __str__(self):
			return f'ptr[{self.value}]'

	@dataclass
	class Command(Type):
		name: Literal['cmd']
		size: Literal[8]
		input: list['Types.Type']
		output: 'Types.Type | None'

	@dataclass
	class IntegerOrPointer(Type):
		def __eq__(self, value):
			return type(value) in [Types.Pointer, Types.Integer] and value.size == 8
		
		def __str__(self):
			return 'u64, i64, or ptr'

	u8  = Integer('u8',  1)
	u16 = Integer('u16', 2)
	u32 = Integer('u32', 4)
	u64 = Integer('u64', 8)
	i8  = Integer('i8',  1)
	i16 = Integer('i16', 2)
	i32 = Integer('i32', 4)
	i64 = Integer('i64', 8)
	ptr: Callable[[Type | None], Pointer] = lambda v: Types.Pointer('ptr', 8, v)
	cmd: Callable[[list[Type], Type | None], Command] = lambda inp, out: Types.Command('cmd', 8, inp, out)

	iop = IntegerOrPointer('iop', 8)

class IR:
	@dataclass
	class Code:
		where: Where
	@dataclass
	class ProgramEnter():
		modulesc: int
	@dataclass
	class ProgramLeave():
		pass
	@dataclass
	class FunctionEnter(Code):
		symbol: str
	@dataclass
	class FunctionLeave(Code):
		symbol: str
	@dataclass
	class FunctionCall(Code):
		symbol: str
		argc: int
	@dataclass
	class Syscall(Code):
		argc: int
	@dataclass
	class PushInteger(Code):
		value: int
	@dataclass
	class PushString(Code):
		value: str

@dataclass
class Parser:
	path: Path
	modules: list['Parser.Module'] = None
	ir: list[IR.Code] = None

	@dataclass
	class IntegerExpression:
		where: Where
		value: int
		type: Types.Type = None
	@dataclass
	class StringExpression:
		where: Where
		value: bytes
		type: Types.Type = None
	@dataclass
	class NameExpression:
		where: Where
		value: str
		type: Types.Type = None
	@dataclass
	class BuiltinExpression:
		BUILTINS = Literal['JWLBUILTIN_SYSCALL3']
		where: Where
		value: BUILTINS
		type: Types.Type = None
	PrimaryExpression = BuiltinExpression | NameExpression | StringExpression | IntegerExpression
	@dataclass
	class CommandExpression:
		where: Where
		lhs: 'Parser.PrimaryExpression'
		rhs: list['Parser.PrimaryExpression']
	Expression = CommandExpression | PrimaryExpression
	Statement = Expression
	IndentedBlock = list[Statement]
	@dataclass
	class Module:
		path: str
		index: int
		beg: 'Parser.IndentedBlock'
		end: 'Parser.IndentedBlock'

	def __post_init__(self):
		modules: list[Parser.Module] = []
		ir: list[IR.Code] = []

		def parse_module(path: Path):
			tokens = Tokens(path)
			beg: Parser.IndentedBlock = []
			end: Parser.IndentedBlock = []

			while tokens.value() == 'import':
				raise NotImplementedError
			
			if tokens.value() == 'beg':
				tokens.expect('beg', Tokens.Newline)
				beg = parse_indented_block(tokens, 0)

			if tokens.value() == 'end':
				tokens.expect('end', Tokens.Newline)
				end = parse_indented_block(tokens, 0)

			while tokens.value():
				raise NotImplementedError

			modules.append(Parser.Module(path, len(modules), beg, end))

		def parse_indented_block(tokens: Tokens, level: int) -> Parser.IndentedBlock:
			statements = Parser.IndentedBlock()
			
			if tokens.type() is Tokens.Indent:
				if len(tokens.value()) <= level:
					tokens.front().error(f'expected indented block of level {level + 1} or higher, found level {level}')
				level = len(tokens.value())

				while tokens.type() is Tokens.Indent and len(tokens.value()) == level:
					tokens.expect(Tokens.Indent)
					statements.append(parse_statement(tokens, level))

			return statements

		def parse_statement(tokens: Tokens, level: int) -> Parser.Statement:
			return tokens.follow(parse_expression(tokens), Tokens.Newline)

		def parse_expression(tokens: Tokens) -> Parser.Expression:
			return parse_command_expression(tokens)

		def parse_command_expression(tokens: Tokens) -> Parser.CommandExpression:
			lhs = parse_primary_expression(tokens)

			while tokens.type() not in [Tokens.Newline, Tokens.Indent, Tokens.Symbol]:
				if type(lhs) is not Parser.CommandExpression:
					lhs = Parser.CommandExpression(lhs.where, lhs, [])
				lhs.rhs.append(parse_primary_expression(tokens))

			return lhs

		def parse_primary_expression(tokens: Tokens) -> Parser.PrimaryExpression:
			if tokens.type() is Tokens.Name:
				if tokens.value().startswith('JWLBUILTIN_'):
					if (tokens.value().startswith('JWLBUILTIN_SYSCALL') and not tokens.value()[18:].isdigit()) or \
					tokens.value() not in Parser.BuiltinExpression.BUILTINS.__args__:
						tokens.error(f'no such builtin `{tokens.value()}`')
					return Parser.BuiltinExpression(tokens.where(), tokens.expect(Tokens.Name).value)
				else:
					return Parser.NameExpression(tokens.where(), tokens.expect(Tokens.Name).value)
			elif tokens.type() is Tokens.Integer:
				return Parser.IntegerExpression(tokens.where(), tokens.expect(Tokens.Integer).value)
			elif tokens.type() is Tokens.String:
				return Parser.StringExpression(tokens.where(), tokens.expect(Tokens.String).value)
			else:
				tokens.error('expected expression')

		def typecheck(node: Parser.Module | Parser.Statement):
			match type(node):
				case Parser.Module:
					[typecheck(statement) for statement in node.beg]
					[typecheck(statement) for statement in node.end]
				case Parser.CommandExpression:
					[typecheck(expression) for expression in node.rhs]
					typecheck(node.lhs)
					if type(node.lhs.type) is not Types.Command:
						node.where.error(f'invalid left-hand side type for command expression: expected type `cmd` but found `{node.lhs.type}`')
					elif len(node.rhs) != len(node.lhs.type.input):
						node.where.error('argument-parameter count mismatch')
					for i in range(0, len(node.rhs)):
						if (node.lhs.type.input[i] != node.rhs[i].type):
							node.rhs[i].where.error(f'argument-parameter type mismatch: expected type `{node.lhs.type.input[i]}` but found `{node.rhs[i].type}`')
					node.type = node.lhs.type.output
				case Parser.IntegerExpression:
					node.type = Types.i64
				case Parser.StringExpression:
					node.type = Types.ptr(Types.u8)
				case Parser.BuiltinExpression:
					match node.value:
						case node.value if node.value.startswith('JWLBUILTIN_SYSCALL'):
							node.type = Types.cmd([Types.i64] + [Types.iop] * int(node.value[18:]), Types.i64)
						case _:
							raise NotImplementedError(f'typecheck({node.value})')
				case _:
					raise NotImplementedError(f'typecheck({type(node)})')

		def genir(node: Parser.Module | Parser.Statement):
			match type(node):
				case Parser.Module:
					if len(node.beg):
						ir.append(IR.FunctionEnter(node.beg[0].where, f'mod{node.index}beg'))
						[genir(statement) for statement in node.beg]
						ir.append(IR.FunctionLeave(node.beg[-1].where, f'mod{node.index}beg'))

					if len(node.end):
						ir.append(IR.FunctionEnter(node.end[0].where, f'mod{node.index}end'))
						[genir(statement) for statement in node.end]
						ir.append(IR.FunctionLeave(node.end[-1].where, f'mod{node.index}end'))
				case Parser.CommandExpression:
					[genir(rhs) for rhs in node.rhs]
					genir(node.lhs)
					if type(node.lhs) is not Parser.BuiltinExpression:
						raise NotImplementedError
				case Parser.IntegerExpression:
					ir.append(IR.PushInteger(node.where, node.value))
				case Parser.StringExpression:
					ir.append(IR.PushString(node.where, node.value))
				case Parser.BuiltinExpression:
					match node.value:
						case node.value if node.value.startswith('JWLBUILTIN_SYSCALL'):
							ir.append(IR.Syscall(node.where, int(node.value[18:])))
						case _:
							raise NotImplementedError(f'genir({node.value})')
				case _:
					raise NotImplementedError(f'genir({type(node)})')

		parse_module(self.path)
		[typecheck(module) for module in modules]
		
		ir.append(IR.ProgramEnter(len(modules)))
		for module in modules:
			if len(module.beg):
				ir.append(IR.FunctionCall(module.beg[0].where, f'mod{module.index}beg', 0))
		for module in reversed(modules):
			if len(module.end):
				ir.append(IR.FunctionCall(module.end[0].where, f'mod{module.index}end', 0))
		ir.append(IR.ProgramLeave())
		[genir(module) for module in modules]
		
		self.modules = modules
		self.ir = ir

@dataclass
class Compiler:
	parser: Parser
	target: Literal['exe', 'asm', 'obj']
	output: Path

	def __post_init__(self):
		raise NotImplementedError(self.__class__)

@dataclass
class Linux_x86_64_NASM(Compiler):
	def __post_init__(self):
		@dataclass
		class Entry:
			off: int
			name: str | None = None

			def __str__(self):
				return f'[rbp - {self.off}]'

		@dataclass
		class Stack:
			off: int = 0
			max: int = 0
			entries: list[Entry] = None

			def __post_init__(self):
				self.entries = []

			def push(self, size: int) -> Entry:
				from math import ceil
				self.off = ceil((self.off + size) / size) * size
				self.max = max(self.off, self.max)
				self.entries.append(Entry(self.off))
				return self.entries[-1]
			
			def pop(self) -> Entry:
				entry = self.entries.pop()
				self.off = self.entries[-1].off if len(self.entries) else 0
				return entry

		asm: list[str] = []
		strs: list[str] = []
		stack = Stack()

		for code in self.parser.ir:
			match type(code):
				case IR.ProgramEnter:
					asm = [
						'default rel',
						'global _start',
						'section .text',
						'_start:'
					]
				case IR.ProgramLeave:
					asm += [
						'  mov rdi, 0',
						'  mov rax, 60',
						'  syscall'
					]
				case IR.FunctionCall:
					asm.append(f'  call {code.symbol}')
				case IR.FunctionEnter:
					stack = Stack()
					asm += [
						f'{code.symbol}:',
						'  push rbp',
						'  mov rbp, rsp',
						'#STACKSIZE#'
					]
				case IR.FunctionLeave:
					asm += [
						'  leave',
						'  ret'
					]

					from math import ceil
					asm[asm.index("#STACKSIZE#")] = f'  sub rsp, {ceil(stack.max / 8) * 8}'
				case IR.PushInteger:
					asm += [
						f'  mov rax, {code.value}',
						f'  mov {stack.push(8)}, rax'
					]
				case IR.PushString:
					if code.value not in strs:
						strs.append(code.value)
					asm += [
						f'  lea rax, str{strs.index(code.value)}',
						f'  mov {stack.push(8)}, rax'
					]
				case IR.Syscall:
					for i in range(code.argc - 1, -1, -1):
						if i > 5:
							code.where.error('Linux x86_64 only supports syscalls with up to 6 arguments')
						reg = ('rdi', 'rsi', 'rdx', 'r10', 'r8', 'r9')[i]
						asm.append(f'  mov {reg}, {stack.pop()}')
					asm += [
						f'  mov rax, {stack.pop()}',
						f'  syscall',
						f'  mov {stack.push(8)}, rax'
					]
				case _:
					raise NotImplementedError(f'compile({code})')
				
		if len(strs):
			asm.append('section .data')
			for i in range(0, len(strs)):
				asm += [
					f'str{i}:',
					f'  db {', '.join(str(b) for b in list(strs[i]) + [0])}'
				]
		
		if self.target == 'asm': open(self.output, 'w').write('\n'.join(asm))
		else:
			temp = NamedTemporaryFile('w', delete_on_close=False)
			temp.write('\n'.join(asm))
			temp.close()
			
			if self.target == 'obj':
				run(['nasm', '-f', 'elf64', '-o', self.output, temp.name])
			else:
				temp2 = NamedTemporaryFile('w', delete_on_close=False)
				temp2.close()
				run(['nasm', '-f', 'elf64', '-o', temp2.name, temp.name])
				run(['ld', '-o', self.output, temp2.name])

if __name__ == '__main__':
	import platform
	from sys import argv

	try:
		asm = '-s' in argv
		obj = '-o' in argv

		while '-s' in argv: argv.remove('-s')
		while '-o' in argv: argv.remove('-o')

		if asm and obj:
			raise Error('error: only one of [-s | -o] may be provided')

		if len(argv) != 3:
			raise Error(
				f'usage: {argv[0]} [-s | -o] <input> <output>\n'
				'\n'
				'options:\n'
				'  -s      write assembly to <output>\n'
				'  -o      write assembler\'s output to <output>'
			)
		
		target = f'{platform.system()}-{platform.machine()}'
		targets: dict[str, type[Compiler]] = {
			'Linux-x86_64': Linux_x86_64_NASM
		}

		if target not in targets:
			raise Error(f'error: unsupported platform `{platform.system()} {platform.machine()}`')
		
		compiler = targets[target](Parser(argv[1]), 'exe' if not asm and not obj else 'obj' if obj else 'asm', argv[2])
	except Error as e:
		print(e.msg)