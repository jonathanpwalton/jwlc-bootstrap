#!/usr/bin/env node

// jwlc, a bootstrap compiler for the jwl programming language
// Copyright (C) 2025 Jonathan Walton

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

import * as os from 'os'
import { readFileSync } from 'fs'
import { argv, exit } from 'process'
import { styleText as style } from 'util'

const replaceObject = (a, b) => {
	let tmp = {}
	Object.assign(tmp, b)
	for (let p in a) delete a[p]
	Object.assign(a, tmp)
}

const len = (a) => a.length
const last = (a) => a[a.length - 1]
const print = (...a) => console.log(...a)
const display = (a) => console.dir(a, {depth: null})
const ASSERT = (condition) => { if (!condition) throw Error('assertion failure') }
const readlines = (path) => {
	try {
		return readFileSync(path).toString().replaceAll('\r\n', '\n').replaceAll('\r', '\n').split('\n')
	} catch(err) {
		print(style(['bold', 'redBright'], `error: `) + `${path}: ${/^Error: \S+:/.test(err.toString()) ? err.toString().replaceAll(/^Error: \S+: /g, '').replaceAll(/, [^,]+$/g, '') : err}`)
		exit(1)
	}
}

const where = (path, row, col) => { return { path: path, row: row, col: col, error: function (msg, ...extra) {
	print(style(['bold', 'whiteBright'], `${this.path}:${this.row}:${this.col}: `) + style(['bold', 'redBright'], 'error: ') + msg)
	for (const e of extra) print(e)
	exit(1)
}}}

class TokenKind {
	static EOF = new TokenKind('end of file')
	static Newline = new TokenKind('newline')
	static Indent = new TokenKind('indent')
	static Keyword = new TokenKind('keyword')
	static Word = new TokenKind('word')
	static Integer = new TokenKind('integer')
	static Symbol = new TokenKind('symbol')
	constructor (name) { this.name = name }
}

const tokenize = (path) => {
	let tokens = []
	tokens.lines = readlines(path)
	tokens.index = 0
	tokens.now = function() {	return this[this.index]	}
	tokens.lineCaret = function(token) {
		if (!token) token = this.now()
		return [
			`  ${String(token.where.row).padStart(Math.ceil(len(this.lines) / 10))} | ${this.lines[token.where.row - 1]}`,
			`  ${' '.repeat(Math.ceil(len(this.lines) / 10))} | ${'^'.padStart(token.where.col)}`,
		]
	}
	tokens.expect = function(...expected) {
		let r = []
		for (const e of expected) {
			if (typeof(e) !== 'string' && !(e instanceof TokenKind))
				throw Error(`${e} must be a string or a TokenKind (typeof(e) is ${typeof(e)} and (e isntanceof TokenKind) is ${e instanceof TokenKind})`)

			if (typeof(e) === 'string' && this.now().value != e)
				this.now().where.error(`expected '${e}' but found ${this.now().kind.name} '${this.now().value}'`, ...this.lineCaret())
			else if (e instanceof TokenKind && this.now().kind != e)
				this.now().where.error(`expected ${e.name} but found ${this.now().kind.name} '${this.now().value}'`, ...this.lineCaret())
			r.push(tokens.now())
			this.index += 1
		}
		return len(r) == 1 ? r[0] : r
	}
	tokens.expectone = function (...options) {
		for (const o of options) {
			if (typeof(o) !== 'string' && !(e instanceof TokenKind))
				throw Error(`${o} must be a string or a TokenKind (typeof(e) is ${typeof(o)} and (e isntanceof TokenKind) is ${o instanceof TokenKind})`)

			if (this.now().value == o || this.now().kind == o)
				return this.expect(o)
		}
		this.now().where.error(`expected one of ${options} but found ${this.now().kind.name} '${this.now().value}'`)
	}
	tokens.advance = function () {
		return this[this.index++]
	}

	const content = tokens.lines.join('\n')
	let row = 1, colstart = 0, colend = 0
	for (let i = 0; i < len(content);) {
		let length = 0
		let now = where(path, row, i - colstart + 1)

		if (content[i] == '\n') {
			length = 1
			if (len(tokens) && last(tokens).kind == TokenKind.Indent)
				tokens.pop()
			else if (len(tokens) && last(tokens).kind != TokenKind.Newline)
				tokens.push({kind: TokenKind.Newline, value: '\n', where: now})
			row++
			colstart = i + 1
		} else if (/\s/.test(content[i])) {
			do length++; while(/\s/.test(content[i + length]))
			if (len(tokens) && last(tokens).kind == TokenKind.Newline)
				tokens.push({kind: TokenKind.Newline, value: ' '.repeat(length), where: now})
		} else if (/[A-Za-z]/.test(content[i])) {
			do length++; while (/[A-Za-z0-9_]/.test(content[i + length]))
			tokens.push({kind: TokenKind.Word, value: content.substring(i, i + length), where: now})

			if (['let'].includes(last(tokens).value))
				last(tokens).kind = TokenKind.Keyword
		} else if (/[0-9]/.test(content[i])) {
			do length++; while (/[0-9]/.test(content[i + length]))
			tokens.push({kind: TokenKind.Integer, value: content.substring(i, i + length), where: now})
		} else if (['=', '+', '-', '*', '/', ':', '(', ')'].includes(content[i])) {
			length = 1
			tokens.push({kind: TokenKind.Symbol, value: content[i], where: now})
		} else {
			now.error(`failed to tokenize character '${content[i]}'`)
		}
		i += length
		colend = i - colstart + 1
	}

	if (!last(tokens) || last(tokens).kind != TokenKind.Newline)
		tokens.push({kind: TokenKind.Newline, value: '\n', where: where(path, row, colend) })

	tokens.push({kind: TokenKind.EOF, value: undefined, where: where(path, row, colend + 1)})
	
	return tokens
}

class Type {
	static u8  = new Type('u8',  1, 1, {integral: true})
	static u16 = new Type('u16', 2, 2, {integral: true})
	static u32 = new Type('u32', 4, 4, {integral: true})
	static u64 = new Type('u64', 8, 8, {integral: true})
	static i8  = new Type('i8',  1, 1, {integral: true, signed: true})
	static i16 = new Type('i16', 2, 2, {integral: true, signed: true})
	static i32 = new Type('i32', 4, 4, {integral: true, signed: true})
	static i64 = new Type('i64', 8, 8, {integral: true, signed: true})
	static ptr = (value) => new Type('ptr', 8, 8, {value: value})
	static fun = (input, output) => new Type('fun', 8, 8, input && output ? {input: input, output: output} : input ? {input: input} : output ? {output: output} : {})

	constructor(name, size, alignment, obj) {
		this.name = name
		this.size = size
		this.alignment = alignment

		if (obj !== undefined) {
			Object.assign(this, obj)
		}
	}

	is(other) {
		if (this.name == 'fun' && other.name == 'fun')
			return JSON.stringify(this.input) === JSON.stringify(other.input)
		return JSON.stringify(this) === JSON.stringify(other)
	}

	toString() {
		return this.name
	}
}

const parse = (path) => {
	const INITIALIZERS = {}
	const FUNCTIONS = {add: [], sub: [], mul: [], div: []}
	new Array(Type.u8, Type.u16, Type.u32, Type.u64, Type.i8, Type.i16, Type.i32, Type.i64)
		.forEach(t => {
			INITIALIZERS[t.name] = [{builtin: true, name: t.name, type: t}]
			FUNCTIONS.add.push({builtin: true, name: 'add', type: Type.fun([t, t], t)})
			FUNCTIONS.sub.push({builtin: true, name: 'sub', type: Type.fun([t, t], t)})
			FUNCTIONS.mul.push({builtin: true, name: 'mul', type: Type.fun([t, t], t)})
			FUNCTIONS.div.push({builtin: true, name: 'div', type: Type.fun([t, t], t)})
		}
	)

	let nodes = []
	let modules = []

	function module(path) {
		if (modules.includes(path)) return;
		modules.push(path);

		let tokens = tokenize(path)
		nodes.push({
			kind: 'module',
			path: path,
			content: block(tokens, 0)
		})
		tokens.expect(TokenKind.EOF)
	}

	function block(tokens, indent) {
		let self = {statements: []}

		if (indent)
			throw Error('unimplemented')

		do {
			let stat = statement(tokens, indent + 1)
			if (stat.kind == 'declaration' && len(self.statements.filter((e) => e.name == stat.name)))
				stat.where.error(`redefinition of name '${stat.name}'`)
			self.statements.push(stat)
		} while (!indent && tokens.now().kind != TokenKind.EOF)

		return self
	}

	function statement(tokens, indent) {
		let self = {where: tokens.now().where}
		if (tokens.now().value == 'let') {
			self.kind = 'declaration',
			self.name = tokens.expect('let', TokenKind.Word)[1].value
			self.mutable = tokens.expectone(':', '=').value == ':'
			tokens.expect('=')
			self.expression = expression(tokens)
		} else
			tokens.now().where.error('expected statement');
		tokens.expect(TokenKind.Newline)
		return self
	}

	function expression(tokens) {
		return additive(tokens)
	}

	function additive(tokens) {
		let lhs = multiplicative(tokens)
		while (['+', '-'].includes(tokens.now().value))
			lhs = {
				where: lhs.where,
				kind: 'call',
				lhs: {where: lhs.where, kind: 'word', value: tokens.advance().value == '+' ? 'add' : 'sub'},
				rhs: [lhs, multiplicative(tokens)]
			}
		return lhs
	}
	
	function multiplicative(tokens) {
		let lhs = postfix(tokens)
		while (['*', '/'].includes(tokens.now().value))
			lhs = {
				where: lhs.where,
				kind: 'call',
				lhs: {where: lhs.where, kind: 'word', value: tokens.advance().value == '*' ? 'mul' : 'div'},
				rhs: [lhs, postfix(tokens)]
			}
		return lhs
	}

	function postfix(tokens) {
		let lhs = primary(tokens)
		while (['('].includes(tokens.now().value)) {
			switch (tokens.now().value) {
				case '(': {
					let rhs = []
					tokens.expect('(')
					while (true) {
						rhs.push(expression(tokens))
						if (tokens.now().value == ')')
							break
						tokens.expect(',')
					}
					tokens.expect(')')
					lhs = {where: lhs.where, kind: 'call', lhs: lhs, rhs: rhs}
				} break
				default:
					throw Error('unreachable')
			}
		}
		return lhs
	}

	function primary(tokens) {
		if (tokens.now().kind == TokenKind.Integer)
			return {where: tokens.now().where, kind: 'integer', value: tokens.expect(TokenKind.Integer).value}
		else if (tokens.now().kind == TokenKind.Word)
			return {where: tokens.now().where, kind: 'word', value: tokens.expect(TokenKind.Word).value}
		else
			tokens.now().where.error('expected expression', ...tokens.lineCaret())
	}

	function typecheck(node, expectedType) {
		if (expectedType && !(expectedType instanceof Type))
			throw Error(`unreachable, expectedType is ${JSON.stringify(expectedType)}`)

		switch (node.kind) {
			case 'module':
				for (let s of node.content.statements) typecheck(s)
				break
			case 'declaration':
				if (!typecheck(node.expression) || !node.expression.type)
					node.where.error(`failed to determine type of '${node.name}'`)
				node.type = node.expression.type
				break
			case 'call':
				if (node.lhs.kind == 'word') {
					if (node.lhs.value in INITIALIZERS) {
						let initializers = INITIALIZERS[node.lhs.value]

						for (let initializer of initializers) {
							if (initializer.builtin) {
								if (len(node.rhs) != 1)
									continue
								if (!typecheck(node.rhs[0], initializer.type))
									continue
								node.type = initializer.type
								node.init = initializer
								break
							} else {
								throw Error('unimplemented')
							}
						}
					} else if (node.lhs.value in FUNCTIONS) {
						const fns = expectedType ? FUNCTIONS[node.lhs.value].filter(f => f.type.output.is(expectedType)) : FUNCTIONS[node.lhs.value]

						outer: for (const fn of fns) {
							if (len(fn.type.input) != len(node.rhs))
								continue outer

							for (let i = 0; i < len(node.rhs); i++) {
								if (!typecheck(node.rhs[i], fn.type.input[i]))
									continue outer
							}
							
							node.type = fn.type.output
							node.function = fn
							break outer
						}
					} else {
						node.lhs.where.error(`undefined reference to '${node.lhs.value}'`)
					}
				} else {
					throw Error('unimplemented')
				}
				break
			case 'integer':
				node.type = expectedType && expectedType.integral ? expectedType : undefined
				break
			default:
				throw Error(`unimplemented: typecheck(${node.kind})\n${JSON.stringify(node, null, 2)}`)
		}
		return expectedType ? node.type.is(expectedType) : true
	}

	module(path)
	nodes.forEach(typecheck)
	display(nodes)
	return nodes
}

const compile_linux_x86_64 = (path) => {
	let nodes = parse(path)
}

const main = () => {
	const input = argv[2]
	const output = argv[3]
	
	if (!input || !output) {
		print(`usage: ${argv[1]} <input-path> <output-path>`)
		exit(1)
	}

	switch (`${os.platform()}-${os.machine()}`.toLowerCase()) {
		case 'linux-x86_64':
			compile_linux_x86_64(input)
			break
		default:
			print(style(['bold', 'redBright'], 'error: ') + `${os.platform()} ${os.machine()}: unsupported target system`)
			exit(1)
	}
}

main()