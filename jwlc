#!/usr/bin/env node

// jwlc, a bootstrap compiler for the jwl programming language
// Copyright (C) 2025 Jonathan Walton

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

import * as os from 'os'
import { readFileSync } from 'fs'
import { argv, exit } from 'process'
import { styleText as style } from 'util'

const len = (a) => a.length
const last = (a) => a[a.length - 1]
const print = (...a) => console.log(...a)
const display = (a) => console.dir(a, {depth: null})

const readlines = (path) => {
	try {
		return readFileSync(path).toString().replaceAll('\r\n', '\n').replaceAll('\r', '\n').split('\n')
	} catch(err) {
		print(style(['bold', 'redBright'], `error: `) + `${path}: ${/^Error: \S+:/.test(err.toString()) ? err.toString().replaceAll(/^Error: \S+: /g, '').replaceAll(/, [^,]+$/g, '') : err}`)
		exit(1)
	}
}

const where = (path, row, col) => { return { path: path, row: row, col: col, error: function (msg, ...extra) {
	print(style(['bold', 'whiteBright'], `${this.path}:${this.row}:${this.col}: `) + style(['bold', 'redBright'], 'error: ') + msg)
	for (const e of extra) print(e)
	exit(1)
}}}

class TokenKind {
	static EOF = new TokenKind('end of file')
	static Newline = new TokenKind('newline')
	static Indent = new TokenKind('indent')
	static Keyword = new TokenKind('keyword')
	static Word = new TokenKind('word')
	static Integer = new TokenKind('integer')
	static Symbol = new TokenKind('symbol')
	constructor (name) { this.name = name }
}

const tokenize = (path) => {
	let tokens = []
	tokens.lines = readlines(path)
	tokens.index = 0
	tokens.now = function() {	return this[this.index]	}
	tokens.lineCaret = function() {
		return [
			`  ${String(this.now().where.row).padStart(Math.ceil(len(this.lines) / 10))} | ${this.lines[this.now().where.row - 1]}`,
			`  ${' '.repeat(Math.ceil(len(this.lines) / 10))} | ${'^'.padStart(this.now().where.col)}`,
		]
	}
	tokens.expect = function(...expected) {
		let r = []
		for (const e of expected) {
			if (typeof(e) !== 'string' && !(e instanceof TokenKind))
				throw Error(`${e} must be a string or a TokenKind (typeof(e) is ${typeof(e)} and (e isntanceof TokenKind) is ${e instanceof TokenKind})`)

			if (typeof(e) === 'string' && this.now().value != e)
				this.now().where.error(`expected '${e}' but found ${this.now().kind.name} '${this.now().value}'`, ...this.lineCaret())
			else if (e instanceof TokenKind && this.now().kind != e)
				this.now().where.error(`expected ${e.name} but found ${this.now().kind.name} '${this.now().value}'`, ...this.lineCaret())
			r.push(tokens.now())
			this.index += 1
		}
		return len(r) == 1 ? r[0] : r
	}
	tokens.expectone = function (...options) {
		for (const o of options) {
			if (typeof(o) !== 'string' && !(e instanceof TokenKind))
				throw Error(`${o} must be a string or a TokenKind (typeof(e) is ${typeof(o)} and (e isntanceof TokenKind) is ${o instanceof TokenKind})`)

			if (this.now().value == o || this.now().kind == o)
				return this.expect(o)
		}
		this.now().where.error(`expected one of ${options} but found ${this.now().kind.name} '${this.now().value}'`)
	}
	tokens.advance = function () {
		return this[this.index++]
	}

	const content = tokens.lines.join('\n')
	let row = 1, colstart = 0, colend = 0
	for (let i = 0; i < len(content);) {
		let length = 0
		let now = where(path, row, i - colstart + 1)

		if (content[i] == '\n') {
			length = 1
			if (len(tokens) && last(tokens).kind == TokenKind.Indent)
				tokens.pop()
			else if (len(tokens) && last(tokens).kind != TokenKind.Newline)
				tokens.push({kind: TokenKind.Newline, value: '\n', where: now})
			row++
			colstart = i + 1
		} else if (/\s/.test(content[i])) {
			do length++; while(/\s/.test(content[i + length]))
			if (len(tokens) && last(tokens).kind == TokenKind.Newline)
				tokens.push({kind: TokenKind.Newline, value: ' '.repeat(length), where: now})
		} else if (/[A-Za-z]/.test(content[i])) {
			do length++; while (/[A-Za-z0-9_]/.test(content[i + length]))
			tokens.push({kind: TokenKind.Word, value: content.substring(i, i + length), where: now})

			if (['let'].includes(last(tokens).value))
				last(tokens).kind = TokenKind.Keyword
		} else if (/[0-9]/.test(content[i])) {
			do length++; while (/[0-9]/.test(content[i + length]))
			tokens.push({kind: TokenKind.Integer, value: content.substring(i, i + length), where: now})
		} else if (['=', '+', '-', '*', '/', ':'].includes(content[i])) {
			length = 1
			tokens.push({kind: TokenKind.Symbol, value: content[i], where: now})
		} else {
			now.error(`failed to tokenize character '${content[i]}'`)
		}
		i += length
		colend = i - colstart + 1
	}

	if (!last(tokens) || last(tokens).kind != TokenKind.Newline)
		tokens.push({kind: TokenKind.Newline, value: '\n', where: where(path, row, colend) })

	tokens.push({kind: TokenKind.EOF, value: undefined, where: where(path, row, colend + 1)})
	
	return tokens
}

const parse = (path) => {
	let nodes = []
	let modules = []

	function module(path) {
		if (modules.includes(path)) return;
		modules.push(path);

		let tokens = tokenize(path)
		nodes.push({
			path: path,
			content: block(tokens, 0)
		})
		tokens.expect(TokenKind.EOF)
	}

	function block(tokens, indent) {
		let self = {statements: []}

		if (indent)
			throw Error('unimplemented')

		do {
			let stat = statement(tokens, indent + 1)
			if (stat.kind == 'declaration' && len(self.statements.filter((e) => e.name == stat.name)))
				stat.where.error(`redefinition of name '${stat.name}'`)
			self.statements.push(stat)
		} while (!indent && tokens.now().kind != TokenKind.EOF)

		return self
	}

	function statement(tokens, indent) {
		let self = {where: tokens.now().where}
		if (tokens.now().value == 'let') {
			self.kind = 'declaration',
			self.name = tokens.expect('let', TokenKind.Word)[1].value
			self.mutable = tokens.expectone(':', '=').value == ':'
			tokens.expect('=')
			self.expression = expression(tokens)
		} else
			tokens.now().where.error('expected statement');
		tokens.expect(TokenKind.Newline)
		return self
	}

	function expression(tokens) {
		return additive(tokens)
	}

	function additive(tokens) {
		let lhs = multiplicative(tokens)
		while (['+', '-'].includes(tokens.now().value))
			lhs = {where: lhs.where, kind: tokens.advance().value == '+' ? 'add' : 'sub', lhs: lhs, rhs: multiplicative(tokens)}
		return lhs
	}
	
	function multiplicative(tokens) {
		let lhs = primary(tokens)
		while (['*', '/'].includes(tokens.now().value))
			lhs = {where: lhs.where, kind: tokens.advance().value == '*' ? 'mul' : 'div', lhs: lhs, rhs: primary(tokens)}
		return lhs
	}

	function primary(tokens) {
		if (tokens.now().kind == TokenKind.Integer)
			return {where: tokens.now().where, kind: 'integer', value: tokens.expect(TokenKind.Integer).value}
		else
			tokens.now().where.error('expected expression', ...tokens.lineCaret())
	}

	module(path)
	return nodes
}

const compile_linux_x86_64 = (path) => {
	let nodes = parse(path)
}

const main = () => {
	const input = argv[2]
	const output = argv[3]
	
	if (!input || !output) {
		print(`usage: ${argv[1]} <input-path> <output-path>`)
		exit(1)
	}

	switch (`${os.platform()}-${os.machine()}`.toLowerCase()) {
		case 'linux-x86_64':
			compile_linux_x86_64(input)
			break
		default:
			print(style(['bold', 'redBright'], 'error: ') + `${os.platform()} ${os.machine()}: unsupported target system`)
			exit(1)
	}
}

main()